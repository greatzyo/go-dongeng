["0e8fd6b8d4371f5d9f553ae8873646342b2bcfc9","388a5be6d2bf6fc19a3833bec046833d7758acee",["react","clamp","react-native","./Card","../Header/Header","../../NavigationActions","../../addNavigationHelpers","../SceneView","./TransitionConfigs"],[87,178,275,313,404,520,668,814,932],{"version":3,"sources":["/home/dhamaddam/AndroidStudioProjects/go-dongeng/node_modules/react-navigation/src/views/CardStack/CardStack.js"],"names":["emptyFunction","ANIMATION_DURATION","POSITION_THRESHOLD","RESPOND_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","animatedSubscribeValue","animatedValue","__isNative","Object","keys","_listeners","length","addListener","CardStack","_gestureStartValue","_isResponding","_immediateIndex","_screenDetails","_getScreenDetails","scene","props","screenProps","navigation","router","screenDetails","key","state","route","screenNavigation","options","getScreenOptions","_getTransitionConfig","isModal","mode","getTransitionConfig","transitionConfig","_renderCard","screenInterpolator","style","SceneComponent","getComponentForRouteName","routeName","cardStyle","_renderInnerScene","scenes","forEach","newScene","headerMode","header","renderHeader","passProps","getScreenDetails","layout","width","height","position","resetToIndex","duration","timing","toValue","easing","linear","useNativeDriver","start","backFromIndex","Math","max","backFromScene","find","s","index","dispatch","back","floatingHeader","_getHeaderMode","_renderHeader","isVertical","responder","create","onPanResponderTerminate","_reset","onPanResponderGrant","stopAnimation","value","onMoveShouldSetPanResponder","event","gesture","immediateIndex","currentDragDistance","currentDragPosition","nativeEvent","axisLength","__getValue","axisHasBeenMeasured","screenEdgeDistance","gestureResponseDistance","userGestureResponseDistance","vertical","horizontal","hasDraggedEnough","abs","isOnFirstCard","shouldSetResponder","onPanResponderMove","startValue","axis","axisDistance","currentValue","isRTL","setValue","onPanResponderTerminationRequest","onPanResponderRelease","movedDistance","gestureVelocity","defaultVelocity","velocity","resetDuration","goBackDuration","_goBack","gesturesEnabled","OS","handlers","panHandlers","containerStyle","styles","container","map","flex","flexDirection"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport React, { Component } from 'react';\n\nimport clamp from 'clamp';\nimport {\n  Animated,\n  StyleSheet,\n  PanResponder,\n  Platform,\n  View,\n  I18nManager,\n  Easing,\n} from 'react-native';\n\nimport Card from './Card';\nimport Header from '../Header/Header';\nimport NavigationActions from '../../NavigationActions';\nimport addNavigationHelpers from '../../addNavigationHelpers';\nimport SceneView from '../SceneView';\n\nimport type {\n  NavigationAction,\n  NavigationLayout,\n  NavigationScreenProp,\n  NavigationScene,\n  NavigationRouter,\n  NavigationState,\n  NavigationScreenDetails,\n  NavigationStackScreenOptions,\n  HeaderMode,\n  ViewStyleProp,\n  TransitionConfig,\n} from '../../TypeDefinition';\n\nimport TransitionConfigs from './TransitionConfigs';\n\nconst emptyFunction = () => {};\n\ntype Props = {\n  screenProps?: {},\n  headerMode: HeaderMode,\n  headerComponent?: ReactClass<*>,\n  mode: 'card' | 'modal',\n  navigation: NavigationScreenProp<NavigationState, NavigationAction>,\n  router: NavigationRouter<\n    NavigationState,\n    NavigationAction,\n    NavigationStackScreenOptions\n  >,\n  cardStyle?: ViewStyleProp,\n  onTransitionStart?: () => void,\n  onTransitionEnd?: () => void,\n  style?: any, // TODO: Remove\n  /**\n   * Optional custom animation when transitioning between screens.\n   */\n  transitionConfig?: () => TransitionConfig,\n\n  // NavigationTransitionProps:\n  layout: NavigationLayout,\n  navigation: NavigationScreenProp<NavigationState, NavigationAction>,\n  position: Animated.Value,\n  progress: Animated.Value,\n  scenes: Array<NavigationScene>,\n  scene: NavigationScene,\n  index: number,\n};\n\n/**\n * The max duration of the card animation in milliseconds after released gesture.\n * The actual duration should be always less then that because the rest distance \n * is always less then the full distance of the layout.\n */\nconst ANIMATION_DURATION = 500;\n\n/**\n * The gesture distance threshold to trigger the back behavior. For instance,\n * `1/2` means that moving greater than 1/2 of the width of the screen will\n * trigger a back action\n */\nconst POSITION_THRESHOLD = 1 / 2;\n\n/**\n * The threshold (in pixels) to start the gesture action.\n */\nconst RESPOND_THRESHOLD = 20;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst animatedSubscribeValue = (animatedValue: Animated.Value) => {\n  if (!animatedValue.__isNative) {\n    return;\n  }\n  if (Object.keys(animatedValue._listeners).length === 0) {\n    animatedValue.addListener(emptyFunction);\n  }\n};\n\nclass CardStack extends Component {\n  /**\n   * Used to identify the starting point of the position when the gesture starts, such that it can\n   * be updated according to its relative position. This means that a card can effectively be\n   * \"caught\"- If a gesture starts while a card is animating, the card does not jump into a\n   * corresponding location for the touch.\n   */\n  _gestureStartValue: number = 0;\n\n  // tracks if a touch is currently happening\n  _isResponding: boolean = false;\n\n  /**\n   * immediateIndex is used to represent the expected index that we will be on after a\n   * transition. To achieve a smooth animation when swiping back, the action to go back\n   * doesn't actually fire until the transition completes. The immediateIndex is used during\n   * the transition so that gestures can be handled correctly. This is a work-around for\n   * cases when the user quickly swipes back several times.\n   */\n  _immediateIndex: ?number = null;\n\n  _screenDetails: {\n    [key: string]: ?NavigationScreenDetails<NavigationStackScreenOptions>,\n  } = {};\n\n  props: Props;\n\n  componentWillReceiveProps(props: Props) {\n    if (props.screenProps !== this.props.screenProps) {\n      this._screenDetails = {};\n    }\n    props.scenes.forEach((newScene: *) => {\n      if (\n        this._screenDetails[newScene.key] &&\n        this._screenDetails[newScene.key].state !== newScene.route\n      ) {\n        this._screenDetails[newScene.key] = null;\n      }\n    });\n  }\n\n  _getScreenDetails = (scene: NavigationScene): NavigationScreenDetails<*> => {\n    const { screenProps, navigation, router } = this.props;\n    let screenDetails = this._screenDetails[scene.key];\n    if (!screenDetails || screenDetails.state !== scene.route) {\n      const screenNavigation = addNavigationHelpers({\n        ...navigation,\n        state: scene.route,\n      });\n      screenDetails = {\n        state: scene.route,\n        navigation: screenNavigation,\n        options: router.getScreenOptions(screenNavigation, screenProps),\n      };\n      this._screenDetails[scene.key] = screenDetails;\n    }\n    return screenDetails;\n  };\n\n  _renderHeader(\n    scene: NavigationScene,\n    headerMode: HeaderMode\n  ): ?React.Element<*> {\n    const { header } = this._getScreenDetails(scene).options;\n\n    if (typeof header !== 'undefined' && typeof header !== 'function') {\n      return header;\n    }\n\n    const renderHeader = header || ((props: *) => <Header {...props} />);\n\n    // We need to explicitly exclude `mode` since Flow doesn't see\n    // mode: headerMode override below and reports prop mismatch\n    const { mode, ...passProps } = this.props;\n\n    return renderHeader({\n      ...passProps,\n      scene,\n      mode: headerMode,\n      getScreenDetails: this._getScreenDetails,\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _animatedSubscribe(props: Props) {\n    // Hack to make this work with native driven animations. We add a single listener\n    // so the JS value of the following animated values gets updated. We rely on\n    // some Animated private APIs and not doing so would require using a bunch of\n    // value listeners but we'd have to remove them to not leak and I'm not sure\n    // when we'd do that with the current structure we have. `stopAnimation` callback\n    // is also broken with native animated values that have no listeners so if we\n    // want to remove this we have to fix this too.\n    animatedSubscribeValue(props.layout.width);\n    animatedSubscribeValue(props.layout.height);\n    animatedSubscribeValue(props.position);\n  }\n\n  _reset(resetToIndex: number, duration: number): void {\n    Animated.timing(this.props.position, {\n      toValue: resetToIndex,\n      duration,\n      easing: Easing.linear(),\n      useNativeDriver: this.props.position.__isNative,\n    }).start();\n  }\n\n  _goBack(backFromIndex: number, duration: number) {\n    const { navigation, position, scenes } = this.props;\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this._immediateIndex = toValue;\n\n    Animated.timing(position, {\n      toValue,\n      duration,\n      easing: Easing.linear(),\n      useNativeDriver: position.__isNative,\n    }).start(() => {\n      this._immediateIndex = null;\n      const backFromScene = scenes.find((s: *) => s.index === toValue + 1);\n      if (!this._isResponding && backFromScene) {\n        navigation.dispatch(\n          NavigationActions.back({ key: backFromScene.route.key })\n        );\n      }\n    });\n  }\n\n  render(): React.Element<*> {\n    let floatingHeader = null;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'float') {\n      floatingHeader = this._renderHeader(this.props.scene, headerMode);\n    }\n    const { navigation, position, layout, scene, scenes, mode } = this.props;\n    const { index } = navigation.state;\n    const isVertical = mode === 'modal';\n\n    const responder = PanResponder.create({\n      onPanResponderTerminate: () => {\n        this._isResponding = false;\n        this._reset(index, 0);\n      },\n      onPanResponderGrant: () => {\n        position.stopAnimation((value: number) => {\n          this._isResponding = true;\n          this._gestureStartValue = value;\n        });\n      },\n      onMoveShouldSetPanResponder: (\n        event: { nativeEvent: { pageY: number, pageX: number } },\n        gesture: any\n      ) => {\n        if (index !== scene.index) {\n          return false;\n        }\n        const immediateIndex =\n          this._immediateIndex == null ? index : this._immediateIndex;\n        const currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];\n        const currentDragPosition =\n          event.nativeEvent[isVertical ? 'pageY' : 'pageX'];\n        const axisLength = isVertical\n          ? layout.height.__getValue()\n          : layout.width.__getValue();\n        const axisHasBeenMeasured = !!axisLength;\n\n        // Measure the distance from the touch to the edge of the screen\n        const screenEdgeDistance = currentDragPosition - currentDragDistance;\n        // Compare to the gesture distance relavant to card or modal\n        const {\n          gestureResponseDistance: userGestureResponseDistance = {},\n        } = this._getScreenDetails(scene).options;\n        const gestureResponseDistance = isVertical\n          ? userGestureResponseDistance.vertical ||\n            GESTURE_RESPONSE_DISTANCE_VERTICAL\n          : userGestureResponseDistance.horizontal ||\n            GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n        // GESTURE_RESPONSE_DISTANCE is about 25 or 30. Or 135 for modals\n        if (screenEdgeDistance > gestureResponseDistance) {\n          // Reject touches that started in the middle of the screen\n          return false;\n        }\n\n        const hasDraggedEnough =\n          Math.abs(currentDragDistance) > RESPOND_THRESHOLD;\n\n        const isOnFirstCard = immediateIndex === 0;\n        const shouldSetResponder =\n          hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;\n        return shouldSetResponder;\n      },\n      onPanResponderMove: (event: any, gesture: any) => {\n        // Handle the moving touches for our granted responder\n        const startValue = this._gestureStartValue;\n        const axis = isVertical ? 'dy' : 'dx';\n        const axisDistance = isVertical\n          ? layout.height.__getValue()\n          : layout.width.__getValue();\n        const currentValue =\n          I18nManager.isRTL && axis === 'dx'\n            ? startValue + gesture[axis] / axisDistance\n            : startValue - gesture[axis] / axisDistance;\n        const value = clamp(index - 1, currentValue, index);\n        position.setValue(value);\n      },\n      onPanResponderTerminationRequest: () =>\n        // Returning false will prevent other views from becoming responder while\n        // the navigation view is the responder (mid-gesture)\n        false,\n      onPanResponderRelease: (event: any, gesture: any) => {\n        if (!this._isResponding) {\n          return;\n        }\n        this._isResponding = false;\n\n        const immediateIndex =\n          this._immediateIndex == null ? index : this._immediateIndex;\n\n        // Calculate animate duration according to gesture speed and moved distance\n        const axisDistance = isVertical\n          ? layout.height.__getValue()\n          : layout.width.__getValue();\n        const movedDistance = gesture[isVertical ? 'dy' : 'dx'];\n        const gestureVelocity = gesture[isVertical ? 'vy' : 'vx'];\n        const defaultVelocity = axisDistance / ANIMATION_DURATION;\n        const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n        const resetDuration = movedDistance / velocity;\n        const goBackDuration = (axisDistance - movedDistance) / velocity;\n\n        // To asyncronously get the current animated value, we need to run stopAnimation:\n        position.stopAnimation((value: number) => {\n          // If the speed of the gesture release is significant, use that as the indication\n          // of intent\n          if (gestureVelocity < -0.5) {\n            this._reset(immediateIndex, resetDuration);\n            return;\n          }\n          if (gestureVelocity > 0.5) {\n            this._goBack(immediateIndex, goBackDuration);\n            return;\n          }\n\n          // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n          // and the back will happen.\n          if (value <= index - POSITION_THRESHOLD) {\n            this._goBack(immediateIndex, goBackDuration);\n          } else {\n            this._reset(immediateIndex, resetDuration);\n          }\n        });\n      },\n    });\n\n    const { options } = this._getScreenDetails(scene);\n    const gesturesEnabled =\n      typeof options.gesturesEnabled === 'boolean'\n        ? options.gesturesEnabled\n        : Platform.OS === 'ios';\n\n    const handlers = gesturesEnabled ? responder.panHandlers : {};\n    const containerStyle = [\n      styles.container,\n      this._getTransitionConfig().containerStyle,\n    ];\n\n    return (\n      <View {...handlers} style={containerStyle}>\n        <View style={styles.scenes}>\n          {scenes.map((s: *) => this._renderCard(s))}\n        </View>\n        {floatingHeader}\n      </View>\n    );\n  }\n\n  _getHeaderMode(): HeaderMode {\n    if (this.props.headerMode) {\n      return this.props.headerMode;\n    }\n    if (Platform.OS === 'android' || this.props.mode === 'modal') {\n      return 'screen';\n    }\n    return 'float';\n  }\n\n  _renderInnerScene(\n    SceneComponent: ReactClass<*>,\n    scene: NavigationScene\n  ): React.Element<any> {\n    const { navigation } = this._getScreenDetails(scene);\n    const { screenProps } = this.props;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'screen') {\n      return (\n        <View style={styles.container}>\n          <View style={{ flex: 1 }}>\n            <SceneView\n              screenProps={screenProps}\n              navigation={navigation}\n              component={SceneComponent}\n            />\n          </View>\n          {this._renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n    return (\n      <SceneView\n        screenProps={this.props.screenProps}\n        navigation={navigation}\n        component={SceneComponent}\n      />\n    );\n  }\n\n  _getTransitionConfig = () => {\n    const isModal = this.props.mode === 'modal';\n\n    /* $FlowFixMe */\n    return TransitionConfigs.getTransitionConfig(\n      this.props.transitionConfig,\n      {},\n      {},\n      isModal\n    );\n  };\n\n  _renderCard = (scene: NavigationScene): React.Element<*> => {\n    const { screenInterpolator } = this._getTransitionConfig();\n    const style =\n      screenInterpolator && screenInterpolator({ ...this.props, scene });\n\n    const SceneComponent = this.props.router.getComponentForRouteName(\n      scene.route.routeName\n    );\n\n    return (\n      <Card\n        {...this.props}\n        key={`card_${scene.key}`}\n        style={[style, this.props.cardStyle]}\n        scene={scene}\n      >\n        {this._renderInnerScene(SceneComponent, scene)}\n      </Card>\n    );\n  };\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    // Header is physically rendered after scenes so that Header won't be\n    // covered by the shadows of the scenes.\n    // That said, we'd have use `flexDirection: 'column-reverse'` to move\n    // Header above the scenes.\n    flexDirection: 'column-reverse',\n  },\n  scenes: {\n    flex: 1,\n  },\n});\n\nexport default CardStack;\n"]}]