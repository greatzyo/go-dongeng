["88ea9ba14011b66023daad4b7126fbbc4f57c099","da44c16e97f83792fa90fcd2a1b1f9d371687513",["path-to-regexp","../NavigationActions","./createConfigGetter","./getScreenForRouteName","../StateUtils","./validateRouteConfigMap","./getScreenConfigDeprecated"],[94,220,363,511,657,783,947],{"version":3,"sources":["/home/dhamaddam/AndroidStudioProjects/go-dongeng/node_modules/react-navigation/src/routers/StackRouter.js"],"names":["uniqueBaseId","Date","now","uuidCount","_getUuid","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","screen","router","initialRouteParams","initialRouteName","initialChildRouter","paths","pathPattern","path","matchExact","re","wildcardRe","RegExp","source","toPath","compile","getComponentForState","state","activeChildRoute","routes","index","getComponentForRouteName","getStateForAction","passedAction","action","mapDeprecatedActionAndWarn","route","type","NAVIGATE","undefined","key","navigate","params","RESET","keyIndex","indexOf","childIndex","childRoute","childRouter","replaceAt","childAction","init","push","childRouterNames","i","length","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","SET_PARAMS","lastRoute","find","resetAction","actions","map","BACK","backRouteIndex","backRoute","pop","slice","getPathAndParamsForState","subPath","child","getActionForPathAndParams","pathToResolve","split","pathNameToResolve","queryString","matchedRouteName","pathMatch","pathMatchKeys","entries","exec","nestedAction","join","queryParams","reduce","result","item","nextResult","value","matchResult","asterisk","paramName","name","getScreenOptions","navigationOptions","getScreenConfig"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport pathToRegexp from 'path-to-regexp';\n\nimport NavigationActions from '../NavigationActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getScreenConfigDeprecated from './getScreenConfigDeprecated';\n\nimport type {\n  NavigationAction,\n  NavigationComponent,\n  NavigationNavigateAction,\n  NavigationRouter,\n  NavigationRouteConfigMap,\n  NavigationResetAction,\n  NavigationParams,\n  NavigationState,\n  NavigationStackAction,\n  NavigationStackRouterConfig,\n  NavigationStackScreenOptions,\n} from '../TypeDefinition';\n\nconst uniqueBaseId = `id-${Date.now()}`;\nlet uuidCount = 0;\nfunction _getUuid() {\n  return `${uniqueBaseId}-${uuidCount++}`;\n}\n\nexport default (\n  routeConfigs: NavigationRouteConfigMap,\n  stackConfig: NavigationStackRouterConfig = {}\n): NavigationRouter<*, *, NavigationStackScreenOptions> => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach((routeName: string) => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n  const paths = stackConfig.paths || {};\n\n  // Build paths for each route\n  routeNames.forEach((routeName: string) => {\n    let pathPattern = paths[routeName] || routeConfigs[routeName].path;\n    const matchExact = !!pathPattern && !childRouters[routeName];\n    if (typeof pathPattern !== 'string') {\n      pathPattern = routeName;\n    }\n    const keys = [];\n    let re = pathToRegexp(pathPattern, keys);\n    if (!matchExact) {\n      const wildcardRe = pathToRegexp(`${pathPattern}/*`, keys);\n      re = new RegExp(`(?:${re.source})|(?:${wildcardRe.source})`);\n    }\n    /* $FlowFixMe */\n    paths[routeName] = { re, keys, toPath: pathToRegexp.compile(pathPattern) };\n  });\n\n  return {\n    getComponentForState(state: NavigationState): NavigationComponent {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName: string): NavigationComponent {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getStateForAction(\n      passedAction: NavigationStackAction,\n      state: ?NavigationState\n    ) {\n      const action = NavigationActions.mapDeprecatedActionAndWarn(passedAction);\n\n      // Set up the initial state if needed\n      if (!state) {\n        let route = {};\n        if (\n          action.type === NavigationActions.NAVIGATE &&\n          childRouters[action.routeName] !== undefined\n        ) {\n          return {\n            index: 0,\n            routes: [\n              {\n                ...action,\n                type: undefined,\n                key: `Init-${_getUuid()}`,\n              },\n            ],\n          };\n        }\n        if (initialChildRouter) {\n          route = initialChildRouter.getStateForAction(\n            NavigationActions.navigate({\n              routeName: initialRouteName,\n              params: initialRouteParams,\n            })\n          );\n        }\n        const params = (route.params ||\n          action.params ||\n          initialRouteParams) && {\n            ...(route.params || {}),\n            ...(action.params || {}),\n            ...(initialRouteParams || {}),\n          };\n        route = {\n          ...route,\n          routeName: initialRouteName,\n          key: `Init-${_getUuid()}`,\n          ...(params ? { params } : {}),\n        };\n        // eslint-disable-next-line no-param-reassign\n        state = {\n          index: 0,\n          routes: [route],\n        };\n      }\n\n      // Check if a child scene wants to handle the action as long as it is not a reset to the root stack\n      if (action.type !== NavigationActions.RESET || action.key !== null) {\n        const keyIndex = action.key\n          ? StateUtils.indexOf(state, action.key)\n          : -1;\n        const childIndex = keyIndex >= 0 ? keyIndex : state.index;\n        const childRoute = state.routes[childIndex];\n        const childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n          if (route === null) {\n            return state;\n          }\n          if (route && route !== childRoute) {\n            return StateUtils.replaceAt(state, childRoute.key, route);\n          }\n        }\n      }\n\n      // Handle explicit push navigation action\n      if (\n        action.type === NavigationActions.NAVIGATE &&\n        childRouters[action.routeName] !== undefined\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n        if (childRouter) {\n          const childAction =\n            action.action || NavigationActions.init({ params: action.params });\n          route = {\n            params: action.params,\n            ...childRouter.getStateForAction(childAction),\n            key: _getUuid(),\n            routeName: action.routeName,\n          };\n        } else {\n          route = {\n            params: action.params,\n            key: _getUuid(),\n            routeName: action.routeName,\n          };\n        }\n        return StateUtils.push(state, route);\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (action.type === NavigationActions.NAVIGATE) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              return StateUtils.push(state, {\n                ...routeToPush,\n                key: _getUuid(),\n                routeName: childRouterName,\n              });\n            }\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const lastRoute = state.routes.find(\n          /* $FlowFixMe */\n          (route: *) => route.key === action.key\n        );\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === NavigationActions.RESET) {\n        const resetAction: NavigationResetAction = action;\n\n        return {\n          ...state,\n          routes: resetAction.actions.map(\n            (childAction: NavigationNavigateAction) => {\n              const router = childRouters[childAction.routeName];\n              if (router) {\n                return {\n                  ...childAction,\n                  ...router.getStateForAction(childAction),\n                  routeName: childAction.routeName,\n                  key: _getUuid(),\n                };\n              }\n              const route = {\n                ...childAction,\n                key: _getUuid(),\n              };\n              delete route.type;\n              return route;\n            }\n          ),\n          index: action.index,\n        };\n      }\n\n      if (action.type === NavigationActions.BACK) {\n        let backRouteIndex = null;\n        if (action.key) {\n          const backRoute = state.routes.find(\n            /* $FlowFixMe */\n            (route: *) => route.key === action.key\n          );\n          /* $FlowFixMe */\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n        if (backRouteIndex == null) {\n          return StateUtils.pop(state);\n        }\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n          };\n        }\n      }\n      return state;\n    },\n\n    getPathAndParamsForState(\n      state: NavigationState\n    ): { path: string, params?: NavigationParams } {\n      const route = state.routes[state.index];\n      const routeName = route.routeName;\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      /* $FlowFixMe */\n      const subPath = paths[routeName].toPath(route.params);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(route);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    getActionForPathAndParams(pathToResolve: string): ?NavigationAction {\n      // If the path is empty (null or empty string)\n      // just return the initial route action\n      if (!pathToResolve) {\n        return NavigationActions.navigate({\n          routeName: initialRouteName,\n        });\n      }\n\n      const [pathNameToResolve, queryString] = pathToResolve.split('?');\n\n      // Attempt to match `pathNameToResolve` with a route in this router's\n      // routeConfigs\n      let matchedRouteName;\n      let pathMatch;\n      let pathMatchKeys;\n\n      // eslint-disable-next-line no-restricted-syntax\n      for (const [routeName, path] of Object.entries(paths)) {\n        /* $FlowFixMe */\n        const { re, keys } = path;\n        pathMatch = re.exec(pathNameToResolve);\n        if (pathMatch && pathMatch.length) {\n          pathMatchKeys = keys;\n          matchedRouteName = routeName;\n          break;\n        }\n      }\n\n      // We didn't match -- return null\n      if (!matchedRouteName) {\n        return null;\n      }\n\n      // Determine nested actions:\n      // If our matched route for this router is a child router,\n      // get the action for the path AFTER the matched path for this\n      // router\n      let nestedAction;\n      if (childRouters[matchedRouteName]) {\n        nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(\n          /* $FlowFixMe */\n          pathMatch.slice(pathMatchKeys.length).join('/')\n        );\n      }\n\n      // reduce the items of the query string. any query params may\n      // be overridden by path params\n      const queryParams = (queryString || '')\n        .split('&')\n        .reduce((result: *, item: string) => {\n          if (item !== '') {\n            const nextResult = result || {};\n            const [key, value] = item.split('=');\n            nextResult[key] = value;\n            return nextResult;\n          }\n          return result;\n        }, null);\n\n      // reduce the matched pieces of the path into the params\n      // of the route. `params` is null if there are no params.\n      /* $FlowFixMe */\n      const params = pathMatch\n        .slice(1)\n        .reduce((result: *, matchResult: *, i: number) => {\n          const key = pathMatchKeys[i];\n          if (key.asterisk || !key) {\n            return result;\n          }\n          const nextResult = result || {};\n          const paramName = key.name;\n          nextResult[paramName] = matchResult;\n          return nextResult;\n        }, queryParams);\n\n      return NavigationActions.navigate({\n        routeName: matchedRouteName,\n        ...(params ? { params } : {}),\n        ...(nestedAction ? { action: nestedAction } : {}),\n      });\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.navigationOptions\n    ),\n\n    getScreenConfig: getScreenConfigDeprecated,\n  };\n};\n"]}]