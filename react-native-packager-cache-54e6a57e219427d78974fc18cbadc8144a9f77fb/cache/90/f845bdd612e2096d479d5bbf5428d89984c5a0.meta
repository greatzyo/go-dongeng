["c6c82bd89b52f639b54121d3ed3dede8a5338667","de8b71a8c5f51df77fa9b2a3e43fed5e4551721a",["../utils/invariant","./getScreenForRouteName","./createConfigGetter","../NavigationActions","./validateRouteConfigMap","./getScreenConfigDeprecated"],[91,219,373,517,664,828],{"version":3,"sources":["/home/dhamaddam/AndroidStudioProjects/go-dongeng/node_modules/react-navigation/src/routers/TabRouter.js"],"names":["routeConfigs","config","order","Object","keys","paths","initialRouteName","initialRouteIndex","indexOf","backBehavior","shouldBackNavigateToInitialRoute","tabRouters","forEach","routeName","routeConfig","path","screen","router","map","n","join","getStateForAction","action","inputState","mapDeprecatedActionAndWarn","state","routes","tabRouter","childAction","init","params","key","index","type","INIT","route","activeTabLastState","activeTabRouter","activeTabState","activeTabIndex","isBackEligible","BACK","didNavigate","NAVIGATE","navigateAction","find","tabId","i","childState","newChildState","SET_PARAMS","lastRoute","tabState","getComponentForState","childRouter","getComponentForRouteName","getPathAndParamsForState","subPath","child","getActionForPathAndParams","parts","split","pathToTest","navigate","slice","getScreenOptions","navigationOptions","getScreenConfig"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport NavigationActions from '../NavigationActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getScreenConfigDeprecated from './getScreenConfigDeprecated';\n\nimport type {\n  NavigationAction,\n  NavigationComponent,\n  NavigationScreenComponent,\n  NavigationState,\n  NavigationRouteConfigMap,\n  NavigationParams,\n  NavigationRouter,\n  NavigationRoute,\n  NavigationNavigateAction,\n  NavigationTabRouterConfig,\n  NavigationTabScreenOptions,\n} from '../TypeDefinition';\n\nexport default (\n  routeConfigs: NavigationRouteConfigMap,\n  config: NavigationTabRouterConfig = {}\n): NavigationRouter<*, *, *> => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n  const paths = config.paths || {};\n  const initialRouteName = config.initialRouteName || order[0];\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  const backBehavior = config.backBehavior || 'initialRoute';\n  const shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  const tabRouters = {};\n  order.forEach((routeName: string) => {\n    const routeConfig = routeConfigs[routeName];\n    paths[routeName] =\n      typeof routeConfig.path === 'string' ? routeConfig.path : routeName;\n    tabRouters[routeName] = null;\n    if (routeConfig.screen && routeConfig.screen.router) {\n      tabRouters[routeName] = routeConfig.screen.router;\n    }\n  });\n  invariant(\n    initialRouteIndex !== -1,\n    `Invalid initialRouteName '${initialRouteName}' for TabRouter. ` +\n      `Should be one of ${order.map((n: *) => `\"${n}\"`).join(', ')}`\n  );\n  return {\n    getStateForAction(\n      action: NavigationAction | { action: NavigationAction },\n      inputState?: ?NavigationState\n    ): ?NavigationState {\n      // eslint-disable-next-line no-param-reassign\n      action = NavigationActions.mapDeprecatedActionAndWarn(action);\n\n      // Establish a default state\n      let state = inputState;\n      if (!state) {\n        const routes = order.map((routeName: string) => {\n          const tabRouter = tabRouters[routeName];\n          if (tabRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                ...(action.params ? { params: action.params } : {}),\n              });\n            return {\n              ...tabRouter.getStateForAction(childAction),\n              key: routeName,\n              routeName,\n            };\n          }\n          return {\n            key: routeName,\n            routeName,\n          };\n        });\n        state = {\n          routes,\n          index: initialRouteIndex,\n        };\n        // console.log(`${order.join('-')}: Initial state`, {state});\n      }\n\n      if (action.type === NavigationActions.INIT) {\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(\n            (route: *) =>\n              ({\n                ...route,\n                params: {\n                  ...route.params,\n                  ...params,\n                },\n              }: NavigationRoute)\n          );\n        }\n      }\n\n      // Let the current tab handle it\n      const activeTabLastState = state.routes[state.index];\n      const activeTabRouter = tabRouters[order[state.index]];\n      if (activeTabRouter) {\n        const activeTabState = activeTabRouter.getStateForAction(\n          action.action || action,\n          activeTabLastState\n        );\n        if (!activeTabState && inputState) {\n          return null;\n        }\n        if (activeTabState && activeTabState !== activeTabLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeTabState;\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner tabs to change first\n      let activeTabIndex = state.index;\n      const isBackEligible =\n        action.key == null || action.key === activeTabLastState.key;\n      if (\n        action.type === NavigationActions.BACK &&\n        isBackEligible &&\n        shouldBackNavigateToInitialRoute\n      ) {\n        activeTabIndex = initialRouteIndex;\n      }\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        const navigateAction = ((action: *): NavigationNavigateAction);\n        didNavigate = !!order.find((tabId: string, i: number) => {\n          if (tabId === navigateAction.routeName) {\n            activeTabIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeTabIndex];\n          let newChildState;\n\n          const tabRouter = tabRouters[action.routeName];\n\n          if (action.action) {\n            newChildState = tabRouter\n              ? tabRouter.getStateForAction(action.action, childState)\n              : null;\n          } else if (!tabRouter && action.params) {\n            newChildState = {\n              ...childState,\n              params: {\n                ...(childState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState && newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeTabIndex] = newChildState;\n            return {\n              ...state,\n              routes,\n              index: activeTabIndex,\n            };\n          }\n        }\n      }\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const lastRoute = state.routes.find(\n          /* $FlowFixMe */\n          (route: *) => route.key === action.key\n        );\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = ({\n            ...lastRoute,\n            params,\n          }: NavigationRoute);\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n      if (activeTabIndex !== state.index) {\n        return {\n          ...state,\n          index: activeTabIndex,\n        };\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return null;\n      }\n\n      // Let other tabs handle it and switch to the first tab that returns a new state\n      let index = state.index;\n      /* $FlowFixMe */\n      let routes: Array<NavigationState> = state.routes;\n      order.find((tabId: string, i: number) => {\n        const tabRouter = tabRouters[tabId];\n        if (i === index) {\n          return false;\n        }\n        let tabState = routes[i];\n        if (tabRouter) {\n          // console.log(`${order.join('-')}: Processing child router:`, {action, tabState});\n          tabState = tabRouter.getStateForAction(action, tabState);\n        }\n        if (!tabState) {\n          index = i;\n          return true;\n        }\n        if (tabState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = tabState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n      // console.log(`${order.join('-')}: Processed other tabs:`, {lastIndex: state.index, index});\n\n      if (index !== state.index || routes !== state.routes) {\n        return {\n          ...state,\n          index,\n          routes,\n        };\n      }\n      return state;\n    },\n\n    getComponentForState(\n      state: NavigationState\n    ): NavigationScreenComponent<*, NavigationTabScreenOptions> {\n      const routeName = order[state.index];\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = tabRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName: string): NavigationComponent {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state: NavigationState) {\n      const route = state.routes[state.index];\n      const routeName = order[state.index];\n      const subPath = paths[routeName];\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(route);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    /**\n     * Gets an optional action, based on a relative path and query params.\n     *\n     * This will return null if there is no action matched\n     */\n    getActionForPathAndParams(path: string, params: ?NavigationParams) {\n      return (\n        order\n          .map((tabId: string) => {\n            const parts = path.split('/');\n            const pathToTest = paths[tabId];\n            if (parts[0] === pathToTest) {\n              const tabRouter = tabRouters[tabId];\n              const action: NavigationNavigateAction = NavigationActions.navigate(\n                {\n                  routeName: tabId,\n                }\n              );\n              if (tabRouter && tabRouter.getActionForPathAndParams) {\n                action.action = tabRouter.getActionForPathAndParams(\n                  parts.slice(1).join('/'),\n                  params\n                );\n              } else if (params) {\n                action.params = params;\n              }\n              return action;\n            }\n            return null;\n          })\n          .find((action: *) => !!action) ||\n        order\n          .map((tabId: string) => {\n            const tabRouter = tabRouters[tabId];\n            return (\n              tabRouter && tabRouter.getActionForPathAndParams(path, params)\n            );\n          })\n          .find((action: *) => !!action) ||\n        null\n      );\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.navigationOptions\n    ),\n\n    getScreenConfig: getScreenConfigDeprecated,\n  };\n};\n"]}]