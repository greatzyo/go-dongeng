["2209aafe28c7f6f2cf8e295c05c039112c890bd6","8a3ea1e772873ed60c8b302e1a5a09a1dbb39077",["../utils/invariant","../utils/shallowEqual"],[124,243],{"version":3,"sources":["/home/dhamaddam/AndroidStudioProjects/go-dongeng/node_modules/react-navigation/src/views/ScenesReducer.js"],"names":["ScenesReducer","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","scenes","nextState","prevState","prevScenes","Map","freshScenes","staleScenes","forEach","scene","set","nextKeys","Set","routes","has","add","delete","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\n\nimport type {\n  NavigationRoute,\n  NavigationScene,\n  NavigationState,\n} from '../TypeDefinition';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one: string, two: string): number {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one: NavigationScene, two: NavigationScene): number {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(\n  one: NavigationScene,\n  two: NavigationScene\n): boolean {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(\n  one: ?NavigationRoute,\n  two: ?NavigationRoute\n): boolean {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(\n  scenes: Array<NavigationScene>,\n  nextState: NavigationState,\n  prevState: ?NavigationState\n): Array<NavigationScene> {\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes: Map<string, NavigationScene> = new Map();\n  const freshScenes: Map<string, NavigationScene> = new Map();\n  const staleScenes: Map<string, NavigationScene> = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach((scene: *) => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  nextState.routes.forEach((route: *, index: *) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n    const scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n    };\n    invariant(\n      !nextKeys.has(key),\n      `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n        'another route!'\n    );\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevState.routes.forEach((route: NavigationRoute, index: *) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      staleScenes.set(key, {\n        index,\n        isActive: false,\n        isStale: true,\n        key,\n        route,\n      });\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = (nextScene: *) => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene: *, ii: *) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  invariant(\n    activeScenesCount === 1,\n    'there should always be only one scene active, not %s.',\n    activeScenesCount\n  );\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene: *, index: *) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"]}]